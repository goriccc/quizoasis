# QuizOasis Development Rules

## General Development Principles
- When developing new features, existing features must never be modified.
- However, if deemed necessary for efficient and optimized development, ask first and proceed.
- Please develop it to be optimized for SEO.

## Test Development - Critical Rules (Based on Previous Mistakes)

### 1. Component Copy Selection
‚ùå DON'T copy from tests with different data structures (SignalTestClient has multilingual arrays)
‚úÖ DO copy from tests with same structure (AttachmentTestClient for Korean-only ‚Üí multilingual conversion)
Rule: Match source template's data structure to target test's initial requirements

### 2. Data Structure First
‚ùå DON'T start with Korean strings then convert to multilingual objects later
‚úÖ DO design multilingual structure (Record<string, string>) from the beginning
Rule: Define interface with multilingual structure before writing any data

### 3. Component-Data Structure Alignment
‚ùå DON'T keep component expecting multilingual data when data is Korean-only strings
‚úÖ DO ensure component data access matches actual data structure
Rule: Component renders must match data type (string vs Record<string, string>)

### 4. Route Configuration Check
‚ùå DON'T forget to update component import in route file
‚úÖ DO verify correct component is rendered for new slug
Critical: Check that slug === 'new-test' ? NewTestClient is in routing logic

### 5. Complete Translation Keys
‚ùå DON'T miss UI element translation keys (shareResult, retake, otherTests, etc.)
‚úÖ DO add all UI text keys before testing: startMessage(6) + ui(9+) + result(10+)
Rule: Prepare complete translation set: startMessage, ui, result sections

### 6. Emoji Duplication
‚ùå DON'T add emojis in both component hardcode AND translation files
‚úÖ DO include emojis only in translation files
Rule: If translation has emoji, remove from component template literal

### 7. Cache Clearing Protocol
When code changes don't reflect:
Kill all Node processes: taskkill /F /IM node.exe
Delete .next folder: Remove-Item -Path .next -Recurse -Force
Restart dev server: npm run dev
Browser hard refresh: Ctrl+Shift+R

### 8. Supabase Route Block Structure
‚úÖ DO create complete if-block with Supabase fetch + fallback + return statement
‚úÖ DO ensure correct TestClient component is used in return
Pattern: if (slug === 'test-name') { const test = await getTestBySlug() || fallback; return <TestClient .../> }

## Social Sharing Multilingual Requirements (CRITICAL)

### 9. Social Sharing Message Localization
‚ùå DON'T hardcode Korean sharing messages in social sharing functions
‚úÖ DO implement multilingual sharing messages for ALL social sharing functions
Rule: Every social sharing function must support all 7 languages (ko, en, ja, zh-CN, zh-TW, vi, id)

### 10. Social Sharing Functions to Localize
‚úÖ DO localize ALL of these functions:
- handleShareResult() - Default sharing function
- shareToWeChat() - WeChat sharing
- shareToWhatsApp() - WhatsApp sharing  
- shareToKakao() - KakaoTalk sharing
- shareToTelegram() - Telegram sharing
- copyLink() - Link copy function

### 11. Social Sharing Message Pattern
‚úÖ DO use this pattern for all sharing messages:
```typescript
const shareMessages = {
  ko: `ÎÇòÏùò Ïó∞Ïï† Ïû•Ïï†Î¨ºÏùÄ ${resultTitle}! ÎÑàÎäî Î≠êÍ∞Ä Î¨∏Ï†úÏïº? Í∞ôÏù¥ Ìï¥Î≥¥Ïûê üòÇüíî`,
  en: `My love obstacle is ${resultTitle}! What's your problem? Let's try together üòÇüíî`,
  ja: `ÁßÅ„ÅÆÊÅãÊÑõÈöúÂÆ≥„ÅØ${resultTitle}ÔºÅ„ÅÇ„Å™„Åü„ÅÆÂïèÈ°å„ÅØ‰ΩïÔºü‰∏ÄÁ∑í„Å´„ÇÑ„Å£„Å¶„Åø„Çà„ÅÜ üòÇüíî`,
  'zh-CN': `ÊàëÁöÑÊÅãÁà±ÈöúÁ¢çÊòØ${resultTitle}ÔºÅ‰Ω†ÁöÑÈóÆÈ¢òÊòØ‰ªÄ‰πàÔºü‰∏ÄËµ∑ËØïËØïÂêß üòÇüíî`,
  'zh-TW': `ÊàëÁöÑÊàÄÊÑõÈöúÁ§ôÊòØ${resultTitle}ÔºÅ‰Ω†ÁöÑÂïèÈ°åÊòØ‰ªÄÈ∫ºÔºü‰∏ÄËµ∑Ë©¶Ë©¶Âêß üòÇüíî`,
  vi: `Tr·ªü ng·∫°i t√¨nh y√™u c·ªßa t√¥i l√† ${resultTitle}! V·∫•n ƒë·ªÅ c·ªßa b·∫°n l√† g√¨? C√πng th·ª≠ nh√© üòÇüíî`,
  id: `Hambatan cinta saya adalah ${resultTitle}! Apa masalah Anda? Mari coba bersama üòÇüíî`
};
```

### 12. Alert Message Localization
‚úÖ DO localize ALL alert messages in sharing functions:
- Clipboard copy success messages
- Sharing feature error messages  
- WeChat link copy instructions
- Any user-facing text in sharing functions

## Multilingual Content Processing (CRITICAL)

### 13. Multilingual Comma Separation
‚ùå DON'T:
- Use only English comma (,) for splitting multilingual content
- Assume all languages use the same comma characters
- Hardcode comma separation without considering language-specific punctuation
‚úÖ DO:
- Support multiple comma types: English (,), Japanese („ÄÅ), Chinese (Ôºå)
- Use regex pattern for comprehensive comma detection: /,\s+|Ôºå\s*|„ÄÅ\s*/
- Implement proper trimming and filtering for split results
- Test comma separation in all supported languages

### 14. Multilingual Comma Separation Implementation Pattern
‚úÖ DO use this pattern for splitting multilingual comma-separated content:
```typescript
const splitByCommas = (text: string) => {
  // ÏâºÌëú Îí§ Í≥µÎ∞±ÏùÑ Ìè¨Ìï®Ìïú Ìå®ÌÑ¥ÏúºÎ°ú Î∂ÑÌï†
  return text.split(/,\s+|Ôºå\s*|„ÄÅ\s*/).map(item => item.trim()).filter(item => item.length > 0);
};

// Usage for result sections:
const resultSymptoms = splitByCommas(result.symptoms[locale] || result.symptoms.ko);
const resultPattern = splitByCommas(result.patterns[locale] || result.patterns.ko);
const resultRootCause = splitByCommas(result.causes[locale] || result.causes.ko);
const resultSolution = splitByCommas(result.solutions[locale] || result.solutions.ko);
```

### 15. Multilingual Text Implementation
‚ùå DON'T:
- Hardcode Korean text in UI components without considering multilingual support
- Use string literals directly in components without locale-based conditional rendering
- Display variable names instead of actual values in template literals
- Use incorrect variable interpolation syntax
‚úÖ DO:
- Implement locale-based conditional rendering for all user-facing text
- Use Record<string, string> structure for multilingual data from the beginning
- Ensure proper variable interpolation: ${variableName} not [variableName]
- Use correct variable extraction: typeof result.title === 'string' ? result.title : result.title[locale] || result.title.ko

## File Size Management and Incremental Development (CRITICAL)

### 16. File Size Guidelines
‚úÖ DO keep files manageable:
- **Data files**: Max 500-800 lines per file
- **Component files**: Max 300-500 lines per file
- **Large data sets**: Split into multiple files (e.g., questions.ts, results.ts)
- **Complex components**: Split into smaller sub-components

### 17. Incremental Development Strategy
‚úÖ DO follow this pattern for large implementations:
1. **Phase 1**: Create basic structure and interfaces
2. **Phase 2**: Implement core functionality (one feature at a time)
3. **Phase 3**: Add multilingual support (one language at a time)
4. **Phase 4**: Add UI elements (one section at a time)
5. **Phase 5**: Add social sharing (one platform at a time)
6. **Phase 6**: Testing and refinement

### 18. Tool Timeout Prevention
‚ùå DON'T:
- Create massive files that cause "Tool call ended before result was received" errors
- Try to implement everything in a single large operation
- Work with files that are too large to process efficiently
- Process entire large files in one operation
- Try to implement all languages simultaneously
- Work with files over 1000 lines in single operations
‚úÖ DO:
- Break down large files into smaller, manageable units
- Implement features incrementally, step by step
- Split large operations into smaller chunks
- Process one language at a time
- Commit changes frequently
- Use incremental updates

## Production Build Requirements

### 19. ESLint Build Errors Prevention
‚ùå DON'T:
- Use unescaped quotes (") and apostrophes (') in JSX text content
- Ignore ESLint warnings during development that become build errors in production
- Leave special characters unescaped in template literals within JSX
‚úÖ DO:
- Always escape quotes in JSX: " ‚Üí &quot; or &ldquo; or &#34;
- Always escape apostrophes in JSX: ' ‚Üí &apos; or &lsquo; or &#39;
- Test production builds (npm run build) before deployment
- Fix all ESLint errors, not just warnings, before committing

### 20. Production Build Validation
‚ùå DON'T:
- Deploy without running production build validation
- Assume development server success means production will work
- Ignore build-time ESLint errors
‚úÖ DO:
- Always run npm run build before deployment
- Fix all ESLint errors that prevent successful builds
- Validate production build locally before pushing to repository
- Treat build errors as deployment blockers

## Development Order (Corrected):
1. Choose correct source template based on data structure
2. Define multilingual interface first
3. Copy component matching structure
4. Update all imports and type references
5. Add route with correct component mapping
6. Prepare all translation keys (all languages)
7. Fill multilingual data
8. **CRITICAL: Implement multilingual social sharing messages**
9. **CRITICAL: Implement multilingual comma separation**
10. Test with cache clearing
11. Verify all UI elements have translations
12. **CRITICAL: Test social sharing in all languages**

## Pre-Development Checklist:
[ ] Source template matches target data structure?
[ ] Interface defined with Record<string, string>?
[ ] All translation keys prepared in all 7 languages?
[ ] Component imports updated?
[ ] Route mapping includes new test slug?
[ ] Correct TestClient component in route return?
[ ] **Social sharing messages localized for all functions?**
[ ] **All alert messages in sharing functions localized?**
[ ] **Multilingual comma separation implemented?**
[ ] **File size manageable for the operation?**
[ ] **Task broken down into small, manageable steps?**

## SQL Database Integration (CRITICAL)

### 21. SQL File Structure Requirements
‚ùå DON'T:
- Add `created_at` and `updated_at` fields in INSERT statements
- Use `NOW()` functions in SQL INSERT statements
- Include timestamp fields that are auto-managed by database
‚úÖ DO:
- Follow existing SQL file patterns exactly
- Use only essential fields: slug, title, description, thumbnail, type, category, tags, play_count
- Set play_count to 0 for new tests
- Match the exact structure of other test SQL files

### 22. SQL File Creation Checklist
‚úÖ DO verify these fields are included:
- slug: unique test identifier
- title: multilingual JSON object
- description: multilingual JSON object  
- thumbnail: image filename
- type: 'dating' for relationship tests
- category: 'love' for relationship tests
- tags: multilingual array object
- play_count: 0 (initial value)

### 23. SQL File Naming Convention
‚úÖ DO use this pattern: `insert-{test-name}-test.sql`
Examples: `insert-jealousy-test.sql`, `insert-love-obstacles-test.sql`

## UI Consistency Requirements (CRITICAL)

### 24. UI Component Copy Requirements
‚ùå DON'T:
- Create new UI components from scratch when copying existing tests
- Modify button styles, colors, or layouts without explicit user request
- Change CSS classes or styling patterns from the source template
- Ignore existing UI patterns and create different visual designs
‚úÖ DO:
- Copy the EXACT UI components from existing tests (e.g., ConflictTestClient.tsx)
- Maintain identical button styles, colors, gradients, and layouts
- Preserve all CSS classes, spacing, and visual hierarchy
- Ensure UI consistency across all test components
- Only modify content (text, data) while keeping UI structure identical

### 25. UI Consistency Checklist
‚úÖ DO verify these elements match the source template:
- Start button styling and colors
- Progress bar design and animation
- Loading spinner appearance and size
- Question option button styles and colors
- Result view button design
- Share button styling and layout
- Retake/Other tests button arrangement
- Overall background gradients and colors
- All spacing, padding, and margins
- Font sizes, weights, and text styling

### 26. UI Copy Process
‚úÖ DO follow this exact process:
1. Copy the entire source component file (e.g., ConflictTestClient.tsx)
2. Rename the component and file
3. Update imports and data references
4. Modify ONLY the content (questions, results, text)
5. Keep ALL UI styling, CSS classes, and layout identical
6. Test to ensure visual consistency with source template

## Multilingual UI Text Localization (CRITICAL)

### 27. Complete UI Text Localization
‚ùå DON'T:
- Leave hardcoded UI texts in components without multilingual support
- Forget to translate button texts, section headers, and status messages
- Miss UI elements like "Í≤∞Í≥º Î∂ÑÏÑù Ï§ë...", "ÏßÑÌñâÎ•†", "Ï¥ù XÎ™ÖÏù¥ Ï∞∏Ïó¨ÌñàÏñ¥Ïöî!"
- Ignore social sharing button texts and result screen elements
‚úÖ DO:
- Translate ALL UI texts including buttons, headers, status messages
- Use conditional rendering: {locale === 'ko' && 'Korean Text'}
- Cover all UI elements: start screen, progress, loading, results, sharing
- Test all languages to ensure complete localization

### 28. UI Text Localization Checklist
‚úÖ DO verify these elements are translated:
- Start screen: "ÌÖåÏä§Ìä∏ ÏãúÏûë", "ÏπúÍµ¨ÏôÄ Ìï®Íªò Ìï¥Î≥¥Í∏∞", "Ï¥ù XÎ™ÖÏù¥ Ï∞∏Ïó¨ÌñàÏñ¥Ïöî!"
- Progress screen: "ÏßÑÌñâÎ•†", "Í≤∞Í≥º Î∂ÑÏÑù Ï§ë..."
- Result screen: "ÎãπÏã†Ïùò Í≤∞Í≥º", "üéØ ÌäπÏßï", "‚úÖ Ïû•Ï†ê", "‚ö†Ô∏è Îã®Ï†ê", "üí° Ï°∞Ïñ∏"
- Compatibility: "üíñ ÏµúÍ≥† Í∂ÅÌï©", "üòä Ï¢ãÏùÄ Í∂ÅÌï©", "‚ö†Ô∏è Ï£ºÏùò ÌïÑÏöî", "‚ùå Ïñ¥Î†§Ïö¥ Í∂ÅÌï©"
- Action buttons: "Í≤∞Í≥º Í≥µÏú†ÌïòÍ∏∞", "Îã§Ïãú ÌÖåÏä§Ìä∏ÌïòÍ∏∞", "Îã§Î•∏ ÌÖåÏä§Ìä∏ Î≥¥Í∏∞"
- Section headers: "üî• ÏöîÏ¶ò Ïù∏Í∏∞ ÌÖåÏä§Ìä∏ Ï∂îÏ≤ú ÌÜ±5", "ÏóÜÏùå"

### 29. Result Title Emoji Management
‚ùå DON'T:
- Include emojis in result title fields that should be clean text
- Mix emojis in titles with separate emoji fields
‚úÖ DO:
- Keep result titles clean without emojis (e.g., "Í∑πÌïú ÏßàÌà¨Ìòï" not "Í∑πÌïú ÏßàÌà¨Ìòï üî•")
- Use separate emoji field for display purposes
- Remove emojis from all language title fields consistently

### 30. React Rendering Error Prevention
‚ùå DON'T:
- Pass Record<string, string> objects directly as React children
- Render multilingual objects without extracting locale-specific strings
- Use partner.title directly in compatibility sections
‚úÖ DO:
- Always extract strings: typeof field === 'string' ? field : field[locale] || field.ko
- Use proper type checking for multilingual data
- Ensure all rendered content is string type, not object type

### 31. Multilingual Development Process
‚úÖ DO follow this complete process:
1. Create data structure with Record<string, string> from the beginning
2. Implement all UI text localization during initial development
3. Test all languages during development, not after completion
4. Use consistent patterns for all multilingual text handling
5. Verify no hardcoded strings remain in components
6. Test React rendering with all language combinations

## TypeScript Build Error Prevention (CRITICAL)

### 32. TypeScript Index Signature Errors
‚ùå DON'T:
- Use string variables to index objects without proper type checking
- Access multilingual objects with dynamic locale strings without type assertions
- Ignore TypeScript errors during development that become build failures
‚úÖ DO:
- Use type assertions: `obj[locale as keyof typeof obj]`
- Use proper type checking: `typeof field === 'string' ? field : field[locale] || field.ko`
- Fix all TypeScript errors before attempting production builds
- Test builds frequently during development

### 33. Build Process Validation
‚ùå DON'T:
- Skip build validation before deployment
- Ignore TypeScript compilation errors
- Deploy without successful production build
‚úÖ DO:
- Always run `npm run build` before deployment
- Fix all TypeScript errors, not just warnings
- Validate production build locally before pushing
- Use build success as deployment gate

### 34. Development Server Cache Issues
‚ùå DON'T:
- Ignore "Cannot find module" errors in development
- Continue development with corrupted cache
- Skip cache clearing when module errors occur
‚úÖ DO:
- Kill all Node processes: `taskkill /F /IM node.exe`
- Clear Next.js cache: `Remove-Item -Path .next -Recurse -Force`
- Clear node modules cache: `Remove-Item -Path node_modules\.cache -Recurse -Force`
- Restart development server after cache clearing

### 35. TypeScript Error Resolution Process
‚úÖ DO follow this exact process when TypeScript errors occur:
1. Identify the specific TypeScript error and location
2. Use proper type assertions for multilingual objects
3. Add explicit type annotations for function parameters
4. Test build after each fix
5. Clear cache if module errors persist
6. Restart development server if needed

### 36. Build Error Prevention Checklist
‚úÖ DO verify these before deployment:
- [ ] All TypeScript errors resolved
- [ ] Production build successful (`npm run build`)
- [ ] No "Cannot find module" errors
- [ ] All multilingual type assertions working
- [ ] Development server running without errors
- [ ] Cache cleared if module errors occurred

These lessons ensure that future test development will have proper multilingual support from the beginning, avoiding the need for extensive refactoring later.