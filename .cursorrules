# QuizOasis Development Rules

## General Development Principles
- When developing new features, existing features must never be modified.
- However, if deemed necessary for efficient and optimized development, ask first and proceed.
- Please develop it to be optimized for SEO.

## Test Development - Critical Rules (Based on Previous Mistakes)

### 1. Component Copy Selection
âŒ DON'T copy from tests with different data structures (SignalTestClient has multilingual arrays)
âœ… DO copy from tests with same structure (AttachmentTestClient for Korean-only â†’ multilingual conversion)
Rule: Match source template's data structure to target test's initial requirements

### 2. Data Structure First
âŒ DON'T start with Korean strings then convert to multilingual objects later
âœ… DO design multilingual structure (Record<string, string>) from the beginning
Rule: Define interface with multilingual structure before writing any data

### 3. Component-Data Structure Alignment
âŒ DON'T keep component expecting multilingual data when data is Korean-only strings
âœ… DO ensure component data access matches actual data structure
Rule: Component renders must match data type (string vs Record<string, string>)

### 4. Route Configuration Check
âŒ DON'T forget to update component import in route file
âœ… DO verify correct component is rendered for new slug
Critical: Check that slug === 'new-test' ? NewTestClient is in routing logic

### 5. Complete Translation Keys
âŒ DON'T miss UI element translation keys (shareResult, retake, otherTests, etc.)
âœ… DO add all UI text keys before testing: startMessage(6) + ui(9+) + result(10+)
Rule: Prepare complete translation set: startMessage, ui, result sections

### 6. Emoji Duplication
âŒ DON'T add emojis in both component hardcode AND translation files
âœ… DO include emojis only in translation files
Rule: If translation has emoji, remove from component template literal

### 7. Cache Clearing Protocol
When code changes don't reflect:
Kill all Node processes: taskkill /F /IM node.exe
Delete .next folder: Remove-Item -Path .next -Recurse -Force
Restart dev server: npm run dev
Browser hard refresh: Ctrl+Shift+R

### 8. Supabase Route Block Structure
âœ… DO create complete if-block with Supabase fetch + fallback + return statement
âœ… DO ensure correct TestClient component is used in return
Pattern: if (slug === 'test-name') { const test = await getTestBySlug() || fallback; return <TestClient .../> }

## Social Sharing Multilingual Requirements (CRITICAL)

### 9. Social Sharing Message Localization
âŒ DON'T hardcode Korean sharing messages in social sharing functions
âœ… DO implement multilingual sharing messages for ALL social sharing functions
Rule: Every social sharing function must support all 7 languages (ko, en, ja, zh-CN, zh-TW, vi, id)

### 10. Social Sharing Functions to Localize
âœ… DO localize ALL of these functions:
- handleShareResult() - Default sharing function
- shareToWeChat() - WeChat sharing
- shareToWhatsApp() - WhatsApp sharing  
- shareToKakao() - KakaoTalk sharing
- shareToTelegram() - Telegram sharing
- copyLink() - Link copy function

### 11. Social Sharing Message Pattern
âœ… DO use this pattern for all sharing messages:
```typescript
const shareMessages = {
  ko: `ë‚˜ì˜ ì—°ì•  ì¥ì• ë¬¼ì€ ${resultTitle}! ë„ˆëŠ” ë­ê°€ ë¬¸ì œì•¼? ê°™ì´ í•´ë³´ì ğŸ˜‚ğŸ’”`,
  en: `My love obstacle is ${resultTitle}! What's your problem? Let's try together ğŸ˜‚ğŸ’”`,
  ja: `ç§ã®æ‹æ„›éšœå®³ã¯${resultTitle}ï¼ã‚ãªãŸã®å•é¡Œã¯ä½•ï¼Ÿä¸€ç·’ã«ã‚„ã£ã¦ã¿ã‚ˆã† ğŸ˜‚ğŸ’”`,
  'zh-CN': `æˆ‘çš„æ‹çˆ±éšœç¢æ˜¯${resultTitle}ï¼ä½ çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿä¸€èµ·è¯•è¯•å§ ğŸ˜‚ğŸ’”`,
  'zh-TW': `æˆ‘çš„æˆ€æ„›éšœç¤™æ˜¯${resultTitle}ï¼ä½ çš„å•é¡Œæ˜¯ä»€éº¼ï¼Ÿä¸€èµ·è©¦è©¦å§ ğŸ˜‚ğŸ’”`,
  vi: `Trá»Ÿ ngáº¡i tÃ¬nh yÃªu cá»§a tÃ´i lÃ  ${resultTitle}! Váº¥n Ä‘á» cá»§a báº¡n lÃ  gÃ¬? CÃ¹ng thá»­ nhÃ© ğŸ˜‚ğŸ’”`,
  id: `Hambatan cinta saya adalah ${resultTitle}! Apa masalah Anda? Mari coba bersama ğŸ˜‚ğŸ’”`
};
```

### 12. Alert Message Localization
âœ… DO localize ALL alert messages in sharing functions:
- Clipboard copy success messages
- Sharing feature error messages  
- WeChat link copy instructions
- Any user-facing text in sharing functions

## Multilingual Content Processing (CRITICAL)


### 13. Multilingual Text Implementation
âŒ DON'T:
- Hardcode Korean text in UI components without considering multilingual support
- Use string literals directly in components without locale-based conditional rendering
- Display variable names instead of actual values in template literals
- Use incorrect variable interpolation syntax
âœ… DO:
- Implement locale-based conditional rendering for all user-facing text
- Use Record<string, string> structure for multilingual data from the beginning
- Ensure proper variable interpolation: ${variableName} not [variableName]
- Use correct variable extraction: typeof result.title === 'string' ? result.title : result.title[locale] || result.title.ko

## File Size Management and Incremental Development (CRITICAL)

### 14. File Size Guidelines
âœ… DO keep files manageable:
- **Data files**: Max 500-800 lines per file
- **Component files**: Max 300-500 lines per file
- **Large data sets**: Split into multiple files (e.g., questions.ts, results.ts)
- **Complex components**: Split into smaller sub-components

### 15. Incremental Development Strategy
âœ… DO follow this pattern for large implementations:
1. **Phase 1**: Create basic structure and interfaces
2. **Phase 2**: Implement core functionality (one feature at a time)
3. **Phase 3**: Add multilingual support (one language at a time)
4. **Phase 4**: Add UI elements (one section at a time)
5. **Phase 5**: Add social sharing (one platform at a time)
6. **Phase 6**: Testing and refinement

### 16. Tool Timeout Prevention
âŒ DON'T:
- Create massive files that cause "Tool call ended before result was received" errors
- Try to implement everything in a single large operation
- Work with files that are too large to process efficiently
- Process entire large files in one operation
- Try to implement all languages simultaneously
- Work with files over 1000 lines in single operations
âœ… DO:
- Break down large files into smaller, manageable units
- Implement features incrementally, step by step
- Split large operations into smaller chunks
- Process one language at a time
- Commit changes frequently
- Use incremental updates

## Production Build Requirements

### 17. ESLint Build Errors Prevention
âŒ DON'T:
- Use unescaped quotes (") and apostrophes (') in JSX text content
- Ignore ESLint warnings during development that become build errors in production
- Leave special characters unescaped in template literals within JSX
âœ… DO:
- Always escape quotes in JSX: " â†’ &quot; or &ldquo; or &#34;
- Always escape apostrophes in JSX: ' â†’ &apos; or &lsquo; or &#39;
- Test production builds (npm run build) before deployment
- Fix all ESLint errors, not just warnings, before committing

### 18. Production Build Validation
âŒ DON'T:
- Deploy without running production build validation
- Assume development server success means production will work
- Ignore build-time ESLint errors
âœ… DO:
- Always run npm run build before deployment
- Fix all ESLint errors that prevent successful builds
- Validate production build locally before pushing to repository
- Treat build errors as deployment blockers

## Development Order (Corrected):
1. Choose correct source template based on data structure
2. Define multilingual interface first
3. Copy component matching structure
4. Update all imports and type references
5. Add route with correct component mapping
6. Prepare all translation keys (all languages)
7. Fill multilingual data
8. **CRITICAL: Implement multilingual social sharing messages**
9. **CRITICAL: Implement multilingual comma separation**
10. Test with cache clearing
11. Verify all UI elements have translations
12. **CRITICAL: Test social sharing in all languages**

## Pre-Development Checklist:
[ ] Source template matches target data structure?
[ ] Interface defined with Record<string, string>?
[ ] All translation keys prepared in all 7 languages?
[ ] Component imports updated?
[ ] Route mapping includes new test slug?
[ ] Correct TestClient component in route return?
[ ] **Social sharing messages localized for all functions?**
[ ] **All alert messages in sharing functions localized?**
[ ] **Multilingual comma separation implemented?**
[ ] **File size manageable for the operation?**
[ ] **Task broken down into small, manageable steps?**

## SQL Database Integration (CRITICAL)

### 19. SQL File Structure Requirements
âŒ DON'T:
- Add `created_at` and `updated_at` fields in INSERT statements
- Use `NOW()` functions in SQL INSERT statements
- Include timestamp fields that are auto-managed by database
âœ… DO:
- Follow existing SQL file patterns exactly
- Use only essential fields: slug, title, description, thumbnail, type, category, tags, play_count
- Set play_count to 0 for new tests
- Match the exact structure of other test SQL files

### 20. SQL File Creation Checklist
âœ… DO verify these fields are included:
- slug: unique test identifier
- title: multilingual JSON object
- description: multilingual JSON object  
- thumbnail: image filename
- type: 'dating' for relationship tests
- category: 'love' for relationship tests
- tags: multilingual array object
- play_count: 0 (initial value)

### 21. SQL File Naming Convention
âœ… DO use this pattern: `insert-{test-name}-test.sql`
Examples: `insert-jealousy-test.sql`, `insert-love-obstacles-test.sql`

## UI Consistency Requirements (CRITICAL)

### 22. UI Component Copy Requirements
âŒ DON'T:
- Create new UI components from scratch when copying existing tests
- Modify button styles, colors, or layouts without explicit user request
- Change CSS classes or styling patterns from the source template
- Ignore existing UI patterns and create different visual designs
âœ… DO:
- Copy the EXACT UI components from existing tests (e.g., ConflictTestClient.tsx)
- Maintain identical button styles, colors, gradients, and layouts
- Preserve all CSS classes, spacing, and visual hierarchy
- Ensure UI consistency across all test components
- Only modify content (text, data) while keeping UI structure identical

### 23. UI Consistency Checklist
âœ… DO verify these elements match the source template:
- Start button styling and colors
- Progress bar design and animation
- Loading spinner appearance and size
- Question option button styles and colors
- Result view button design
- Share button styling and layout
- Retake/Other tests button arrangement
- Overall background gradients and colors
- All spacing, padding, and margins
- Font sizes, weights, and text styling

### 24. UI Copy Process
âœ… DO follow this exact process:
1. Copy the entire source component file (e.g., ConflictTestClient.tsx)
2. Rename the component and file
3. Update imports and data references
4. Modify ONLY the content (questions, results, text)
5. Keep ALL UI styling, CSS classes, and layout identical
6. Test to ensure visual consistency with source template

## Multilingual UI Text Localization (CRITICAL)

### 25. Complete UI Text Localization
âŒ DON'T:
- Leave hardcoded UI texts in components without multilingual support
- Forget to translate button texts, section headers, and status messages
- Miss UI elements like "ê²°ê³¼ ë¶„ì„ ì¤‘...", "ì§„í–‰ë¥ ", "ì´ Xëª…ì´ ì°¸ì—¬í–ˆì–´ìš”!"
- Ignore social sharing button texts and result screen elements
âœ… DO:
- Translate ALL UI texts including buttons, headers, status messages
- Use conditional rendering: {locale === 'ko' && 'Korean Text'}
- Cover all UI elements: start screen, progress, loading, results, sharing
- Test all languages to ensure complete localization

### 26. UI Text Localization Checklist
âœ… DO verify these elements are translated:
- Start screen: "í…ŒìŠ¤íŠ¸ ì‹œì‘", "ì¹œêµ¬ì™€ í•¨ê»˜ í•´ë³´ê¸°", "ì´ Xëª…ì´ ì°¸ì—¬í–ˆì–´ìš”!"
- Progress screen: "ì§„í–‰ë¥ ", "ê²°ê³¼ ë¶„ì„ ì¤‘..."
- Result screen: "ë‹¹ì‹ ì˜ ê²°ê³¼", "ğŸ¯ íŠ¹ì§•", "âœ… ì¥ì ", "âš ï¸ ë‹¨ì ", "ğŸ’¡ ì¡°ì–¸"
- Compatibility: "ğŸ’– ìµœê³  ê¶í•©", "ğŸ˜Š ì¢‹ì€ ê¶í•©", "âš ï¸ ì£¼ì˜ í•„ìš”", "âŒ ì–´ë ¤ìš´ ê¶í•©"
- Action buttons: "ê²°ê³¼ ê³µìœ í•˜ê¸°", "ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•˜ê¸°", "ë‹¤ë¥¸ í…ŒìŠ¤íŠ¸ ë³´ê¸°"
- Section headers: "ğŸ”¥ ìš”ì¦˜ ì¸ê¸° í…ŒìŠ¤íŠ¸ ì¶”ì²œ í†±5", "ì—†ìŒ"

### 27. Result Title Emoji Management
âŒ DON'T:
- Include emojis in result title fields that should be clean text
- Mix emojis in titles with separate emoji fields
âœ… DO:
- Keep result titles clean without emojis (e.g., "ê·¹í•œ ì§ˆíˆ¬í˜•" not "ê·¹í•œ ì§ˆíˆ¬í˜• ğŸ”¥")
- Use separate emoji field for display purposes
- Remove emojis from all language title fields consistently

### 28. React Rendering Error Prevention
âŒ DON'T:
- Pass Record<string, string> objects directly as React children
- Render multilingual objects without extracting locale-specific strings
- Use partner.title directly in compatibility sections
âœ… DO:
- Always extract strings: typeof field === 'string' ? field : field[locale] || field.ko
- Use proper type checking for multilingual data
- Ensure all rendered content is string type, not object type

### 29. Multilingual Development Process
âœ… DO follow this complete process:
1. Create data structure with Record<string, string> from the beginning
2. Implement all UI text localization during initial development
3. Test all languages during development, not after completion
4. Use consistent patterns for all multilingual text handling
5. Verify no hardcoded strings remain in components
6. Test React rendering with all language combinations

## TypeScript Build Error Prevention (CRITICAL)

### 30. TypeScript Build Error Prevention
âŒ DON'T:
- Use string variables to index objects without proper type checking
- Access multilingual objects with dynamic locale strings without type assertions
- Ignore TypeScript errors during development that become build failures
- Skip build validation before deployment
- Deploy without successful production build
âœ… DO:
- Use type assertions: `obj[locale as keyof typeof obj]`
- Use proper type checking: `typeof field === 'string' ? field : field[locale] || field.ko`
- Fix all TypeScript errors before attempting production builds
- Always run `npm run build` before deployment
- Validate production build locally before pushing
- Test builds frequently during development

### 31. Development Server Cache Issues
âŒ DON'T:
- Ignore "Cannot find module" errors in development
- Continue development with corrupted cache
- Skip cache clearing when module errors occur
âœ… DO:
- Kill all Node processes: `taskkill /F /IM node.exe`
- Clear Next.js cache: `Remove-Item -Path .next -Recurse -Force`
- Clear node modules cache: `Remove-Item -Path node_modules\.cache -Recurse -Force`
- Restart development server after cache clearing

### 32. TypeScript Error Resolution Process
âœ… DO follow this exact process when TypeScript errors occur:
1. Identify the specific TypeScript error and location
2. Use proper type assertions for multilingual objects
3. Add explicit type annotations for function parameters
4. Test build after each fix
5. Clear cache if module errors persist
6. Restart development server if needed

### 33. Build Error Prevention Checklist
âœ… DO verify these before deployment:
- [ ] All TypeScript errors resolved
- [ ] Production build successful (`npm run build`)
- [ ] No "Cannot find module" errors
- [ ] All multilingual type assertions working
- [ ] Development server running without errors
- [ ] Cache cleared if module errors occurred

## Multilingual Comma Pattern Implementation (CRITICAL)

### 34. Language-Specific Comma Separation
âŒ DON'T:
- Use only English comma (,) for all languages
- Assume all languages use the same comma characters
- Hardcode comma separation without considering language-specific punctuation
âœ… DO:
- Support multiple comma types: English (,), Japanese (ã€), Chinese (ï¼Œ)
- Use regex pattern for comprehensive comma detection: /,\s+|ï¼Œ\s*|ã€\s*/
- Implement proper trimming and filtering for split results
- Test comma separation in all supported languages

### 35. Multilingual Comma Separation Implementation Pattern
âœ… DO use this pattern for splitting multilingual comma-separated content:
```typescript
const splitByCommas = (text: string) => {
  // ì‰¼í‘œ ë’¤ ê³µë°±ì„ í¬í•¨í•œ íŒ¨í„´ìœ¼ë¡œ ë¶„í• 
  return text.split(/,\s+|ï¼Œ\s*|ã€\s*/).map(item => item.trim()).filter(item => item.length > 0);
};

// Usage for result sections:
const resultSymptoms = splitByCommas(result.symptoms[locale] || result.symptoms.ko);
const resultPattern = splitByCommas(result.patterns[locale] || result.patterns.ko);
const resultRootCause = splitByCommas(result.causes[locale] || result.causes.ko);
const resultSolution = splitByCommas(result.solutions[locale] || result.solutions.ko);
```

### 36. Data Structure Consistency (CRITICAL)
âŒ DON'T:
- Mix string and Record<string, string> types in the same interface
- Keep unused properties in interfaces (e.g., scores at question level when moved to options)
- Assume data structure matches component expectations without verification
âœ… DO:
- Ensure all multilingual fields use Record<string, string> consistently
- Remove unused properties from interfaces when refactoring
- Verify component rendering logic matches actual data structure
- Test type assertions for all multilingual object access

### 37. Multilingual Data Consistency (CRITICAL)
âŒ DON'T:
- Use different comma patterns in data files vs component rendering
- Mix English commas (,) with Chinese commas (ï¼Œ) in the same data
- Assume all languages use the same punctuation conventions
âœ… DO:
- Use consistent comma patterns in data files for each language
- Chinese (zh-CN, zh-TW): Use Chinese comma (ï¼Œ) in data files
- Japanese (ja): Use Japanese comma (ã€) in data files
- Other languages: Use English comma (,) in data files
- Test comma separation in all languages during development

### 38. Component Data Access Pattern (CRITICAL)
âŒ DON'T:
- Access multilingual objects without proper type checking
- Assume data structure without verification
- Mix string and object access patterns
âœ… DO:
- Use consistent pattern: `typeof field === 'string' ? field : field[locale] || field.ko`
- Extract text first, then split: `const text = field[locale] || field.ko; const array = text.split(pattern)`
- Test all language combinations during development
- Verify type safety for all multilingual object access

### 39. Interface Design for Multilingual Support (CRITICAL)
âŒ DON'T:
- Keep unused properties in interfaces after refactoring
- Mix different data access patterns in the same interface
- Assume interface matches actual usage without verification
âœ… DO:
- Remove unused properties when refactoring data structure
- Use consistent Record<string, string> for all multilingual fields
- Verify interface matches component usage patterns
- Test interface changes with build validation

### 40. Development Process for Multilingual Features (CRITICAL)
âŒ DON'T:
- Implement multilingual features without considering comma patterns
- Skip language-specific testing during development
- Assume all languages work the same way
âœ… DO:
- Plan comma patterns from the beginning of multilingual implementation
- Test comma separation in all supported languages
- Use consistent patterns across all multilingual features
- Validate build after each language-specific change

These lessons ensure that future test development will have proper multilingual support from the beginning, avoiding the need for extensive refactoring later.