# QuizOasis Development Rules

## General Development Principles
- When developing new features, existing features must never be modified.
- However, if deemed necessary for efficient and optimized development, ask first and proceed.
- Please develop it to be optimized for SEO.

## Test Development - Critical Rules (Based on Previous Mistakes)

### 1. ALWAYS Copy from ConflictTestClient (CRITICAL - USER'S MAIN REQUEST)
âŒ DON'T create new test components from scratch or copy from other test components
âŒ DON'T ignore this rule and create components "your way"
âŒ DON'T copy from tests with different data structures (SignalTestClient has multilingual arrays)
âŒ DON'T make UI components from scratch - this causes mistakes and delays
âŒ DON'T modify button styles, colors, gradients, or layouts without explicit user request
âœ… DO ALWAYS copy from "ê°ˆë“± ìƒí™©ì—ì„œ ë‹¹ì‹ ì€ ì–´ë–»ê²Œ ë°˜ì‘í• ê¹Œìš”?" (ConflictTestClient.tsx)
âœ… DO copy the EXACT UI components to ensure identical start screen, progress screen, and result screen
âœ… DO maintain identical button styles, colors, gradients, and layouts
âœ… DO preserve all CSS classes, spacing, and visual hierarchy
âœ… DO follow this exact process: Copy ConflictTestClient.tsx â†’ Rename â†’ Update data references â†’ Keep UI identical
Rule: This is the user's most emphasized rule - ALWAYS copy from ConflictTestClient for new tests to avoid mistakes and ensure fast development

### 2. Component Copy Selection
âŒ DON'T copy from tests with different data structures (SignalTestClient has multilingual arrays)
âœ… DO copy from tests with same structure (AttachmentTestClient for Korean-only â†’ multilingual conversion)
Rule: Match source template's data structure to target test's initial requirements

### 3. Data Structure First
âŒ DON'T start with Korean strings then convert to multilingual objects later
âœ… DO design multilingual structure (Record<string, string>) from the beginning
Rule: Define interface with multilingual structure before writing any data

### 4. Component-Data Structure Alignment
âŒ DON'T keep component expecting multilingual data when data is Korean-only strings
âœ… DO ensure component data access matches actual data structure
Rule: Component renders must match data type (string vs Record<string, string>)

### 5. Route Configuration Check
âŒ DON'T forget to update component import in route file
âœ… DO verify correct component is rendered for new slug
Critical: Check that slug === 'new-test' ? NewTestClient is in routing logic

### 6. Complete Translation Keys
âŒ DON'T miss UI element translation keys (shareResult, retake, otherTests, etc.)
âœ… DO add all UI text keys before testing: startMessage(6) + ui(9+) + result(10+)
Rule: Prepare complete translation set: startMessage, ui, result sections

### 7. Emoji Duplication
âŒ DON'T add emojis in both component hardcode AND translation files
âœ… DO include emojis only in translation files
Rule: If translation has emoji, remove from component template literal

### 8. Cache Clearing Protocol
When code changes don't reflect:
Kill all Node processes: taskkill /F /IM node.exe
Delete .next folder: Remove-Item -Path .next -Recurse -Force
Restart dev server: npm run dev
Browser hard refresh: Ctrl+Shift+R

### 9. Supabase Route Block Structure
âœ… DO create complete if-block with Supabase fetch + fallback + return statement
âœ… DO ensure correct TestClient component is used in return
Pattern: if (slug === 'test-name') { const test = await getTestBySlug() || fallback; return <TestClient .../> }

## Social Sharing Multilingual Requirements (CRITICAL)

### 10. Social Sharing Message Localization
âŒ DON'T hardcode Korean sharing messages in social sharing functions
âœ… DO implement multilingual sharing messages for ALL social sharing functions
Rule: Every social sharing function must support all 7 languages (ko, en, ja, zh-CN, zh-TW, vi, id)

### 11. Social Sharing Functions to Localize
âœ… DO localize ALL of these functions:
- handleShareResult() - Default sharing function
- shareToWeChat() - WeChat sharing
- shareToWhatsApp() - WhatsApp sharing  
- shareToKakao() - KakaoTalk sharing
- shareToTelegram() - Telegram sharing
- copyLink() - Link copy function

### 12. Social Sharing Message Pattern
âœ… DO use this pattern for all sharing messages:
```typescript
const shareMessages = {
  ko: `ë‚˜ì˜ ì—°ì•  ì¥ì• ë¬¼ì€ ${resultTitle}! ë„ˆëŠ” ë­ê°€ ë¬¸ì œì•¼? ê°™ì´ í•´ë³´ì ğŸ˜‚ğŸ’”`,
  en: `My love obstacle is ${resultTitle}! What's your problem? Let's try together ğŸ˜‚ğŸ’”`,
  ja: `ç§ã®æ‹æ„›éšœå®³ã¯${resultTitle}ï¼ã‚ãªãŸã®å•é¡Œã¯ä½•ï¼Ÿä¸€ç·’ã«ã‚„ã£ã¦ã¿ã‚ˆã† ğŸ˜‚ğŸ’”`,
  'zh-CN': `æˆ‘çš„æ‹çˆ±éšœç¢æ˜¯${resultTitle}ï¼ä½ çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿä¸€èµ·è¯•è¯•å§ ğŸ˜‚ğŸ’”`,
  'zh-TW': `æˆ‘çš„æˆ€æ„›éšœç¤™æ˜¯${resultTitle}ï¼ä½ çš„å•é¡Œæ˜¯ä»€éº¼ï¼Ÿä¸€èµ·è©¦è©¦å§ ğŸ˜‚ğŸ’”`,
  vi: `Trá»Ÿ ngáº¡i tÃ¬nh yÃªu cá»§a tÃ´i lÃ  ${resultTitle}! Váº¥n Ä‘á» cá»§a báº¡n lÃ  gÃ¬? CÃ¹ng thá»­ nhÃ© ğŸ˜‚ğŸ’”`,
  id: `Hambatan cinta saya adalah ${resultTitle}! Apa masalah Anda? Mari coba bersama ğŸ˜‚ğŸ’”`
};
```

### 13. Alert Message Localization
âœ… DO localize ALL alert messages in sharing functions:
- Clipboard copy success messages
- Sharing feature error messages  
- WeChat link copy instructions
- Any user-facing text in sharing functions

## Multilingual Content Processing (CRITICAL)


### 14. Multilingual Text Implementation
âŒ DON'T:
- Hardcode Korean text in UI components without considering multilingual support
- Use string literals directly in components without locale-based conditional rendering
- Display variable names instead of actual values in template literals
- Use incorrect variable interpolation syntax
âœ… DO:
- Implement locale-based conditional rendering for all user-facing text
- Use Record<string, string> structure for multilingual data from the beginning
- Ensure proper variable interpolation: ${variableName} not [variableName]
- Use correct variable extraction: typeof result.title === 'string' ? result.title : result.title[locale] || result.title.ko

## File Size Management and Incremental Development (CRITICAL)

### 15. File Size Guidelines
âœ… DO keep files manageable:
- **Data files**: Max 500-800 lines per file
- **Component files**: Max 300-500 lines per file
- **Large data sets**: Split into multiple files (e.g., questions.ts, results.ts)
- **Complex components**: Split into smaller sub-components

### 16. Incremental Development Strategy
âœ… DO follow this pattern for large implementations:
1. **Phase 1**: Create basic structure and interfaces
2. **Phase 2**: Implement core functionality (one feature at a time)
3. **Phase 3**: Add multilingual support (one language at a time)
4. **Phase 4**: Add UI elements (one section at a time)
5. **Phase 5**: Add social sharing (one platform at a time)
6. **Phase 6**: Testing and refinement

### 17. Tool Timeout Prevention
âŒ DON'T:
- Create massive files that cause "Tool call ended before result was received" errors
- Try to implement everything in a single large operation
- Work with files that are too large to process efficiently
- Process entire large files in one operation
- Try to implement all languages simultaneously
- Work with files over 1000 lines in single operations
âœ… DO:
- Break down large files into smaller, manageable units
- Implement features incrementally, step by step
- Split large operations into smaller chunks
- Process one language at a time
- Commit changes frequently
- Use incremental updates

## Production Build Requirements

### 18. ESLint Build Errors Prevention
âŒ DON'T:
- Use unescaped quotes (") and apostrophes (') in JSX text content
- Ignore ESLint warnings during development that become build errors in production
- Leave special characters unescaped in template literals within JSX
âœ… DO:
- Always escape quotes in JSX: " â†’ &quot; or &ldquo; or &#34;
- Always escape apostrophes in JSX: ' â†’ &apos; or &lsquo; or &#39;
- Test production builds (npm run build) before deployment
- Fix all ESLint errors, not just warnings, before committing

### 19. Production Build Validation
âŒ DON'T:
- Deploy without running production build validation
- Assume development server success means production will work
- Ignore build-time ESLint errors
âœ… DO:
- Always run npm run build before deployment
- Fix all ESLint errors that prevent successful builds
- Validate production build locally before pushing to repository
- Treat build errors as deployment blockers

## Development Order (Corrected):
1. Choose correct source template based on data structure
2. Define multilingual interface first
3. Copy component matching structure
4. Update all imports and type references
5. Add route with correct component mapping
6. Prepare all translation keys (all languages)
7. Fill multilingual data
8. **CRITICAL: Implement multilingual social sharing messages**
9. **CRITICAL: Implement multilingual comma separation**
10. Test with cache clearing
11. Verify all UI elements have translations
12. **CRITICAL: Test social sharing in all languages**

## Pre-Development Checklist:
[ ] Source template matches target data structure?
[ ] Interface defined with Record<string, string>?
[ ] All translation keys prepared in all 7 languages?
[ ] Component imports updated?
[ ] Route mapping includes new test slug?
[ ] Correct TestClient component in route return?
[ ] **Social sharing messages localized for all functions?**
[ ] **All alert messages in sharing functions localized?**
[ ] **Multilingual comma separation implemented?**
[ ] **File size manageable for the operation?**
[ ] **Task broken down into small, manageable steps?**

## SQL Database Integration (CRITICAL)

### 20. SQL File Structure Requirements
âŒ DON'T:
- Add `created_at` and `updated_at` fields in INSERT statements
- Use `NOW()` functions in SQL INSERT statements
- Include timestamp fields that are auto-managed by database
âœ… DO:
- Follow existing SQL file patterns exactly
- Use only essential fields: slug, title, description, thumbnail, type, category, tags, play_count
- Set play_count to 0 for new tests
- Match the exact structure of other test SQL files

### 21. SQL File Creation Checklist
âœ… DO verify these fields are included:
- slug: unique test identifier
- title: multilingual JSON object
- description: multilingual JSON object  
- thumbnail: image filename
- type: 'dating' for relationship tests
- category: 'love' for relationship tests
- tags: multilingual array object
- play_count: 0 (initial value)

### 22. SQL File Naming Convention
âœ… DO use this pattern: `insert-{test-name}-test.sql`
Examples: `insert-jealousy-test.sql`, `insert-love-obstacles-test.sql`

### 23. SQL Tags Field Requirements (CRITICAL)
âŒ DON'T:
- Add extra tags beyond what the user specifies in the scenario
- Assume additional tags are needed (e.g., adding "ê°€ì¹˜ê´€", "ì»¤ë¦¬ì–´" when user only specified "#ì§ì—…")
- Create multilingual tag arrays with more items than user requested
âœ… DO:
- Use EXACTLY the tags specified in the user's scenario
- If user specifies only "#ì§ì—…", use only ["ì§ì—…"] in all languages
- Match the user's tag specification precisely without additions
- Follow the pattern: if user says "#ì§ì—…", use ["ì§ì—…"] for all 7 languages

## UI Consistency Requirements (CRITICAL)

### 24. UI Component Copy Requirements
âŒ DON'T:
- Create new UI components from scratch when copying existing tests
- Modify button styles, colors, or layouts without explicit user request
- Change CSS classes or styling patterns from the source template
- Ignore existing UI patterns and create different visual designs
âœ… DO:
- Copy the EXACT UI components from existing tests (e.g., ConflictTestClient.tsx)
- Maintain identical button styles, colors, gradients, and layouts
- Preserve all CSS classes, spacing, and visual hierarchy
- Ensure UI consistency across all test components
- Only modify content (text, data) while keeping UI structure identical

### 25. UI Consistency Checklist
âœ… DO verify these elements match the source template:
- Start button styling and colors
- Progress bar design and animation
- Loading spinner appearance and size
- Question option button styles and colors
- Result view button design
- Share button styling and layout
- Retake/Other tests button arrangement
- Overall background gradients and colors
- All spacing, padding, and margins
- Font sizes, weights, and text styling

### 26. UI Copy Process
âœ… DO follow this exact process:
1. Copy the entire source component file (e.g., ConflictTestClient.tsx)
2. Rename the component and file
3. Update imports and data references
4. Modify ONLY the content (questions, results, text)
5. Keep ALL UI styling, CSS classes, and layout identical
6. Test to ensure visual consistency with source template

## Multilingual UI Text Localization (CRITICAL)

### 27. Complete UI Text Localization
âŒ DON'T:
- Leave hardcoded UI texts in components without multilingual support
- Forget to translate button texts, section headers, and status messages
- Miss UI elements like "ê²°ê³¼ ë¶„ì„ ì¤‘...", "ì§„í–‰ë¥ ", "ì´ Xëª…ì´ ì°¸ì—¬í–ˆì–´ìš”!"
- Ignore social sharing button texts and result screen elements
âœ… DO:
- Translate ALL UI texts including buttons, headers, status messages
- Use conditional rendering: {locale === 'ko' && 'Korean Text'}
- Cover all UI elements: start screen, progress, loading, results, sharing
- Test all languages to ensure complete localization

### 28. UI Text Localization Checklist
âœ… DO verify these elements are translated:
- Start screen: "í…ŒìŠ¤íŠ¸ ì‹œì‘", "ì¹œêµ¬ì™€ í•¨ê»˜ í•´ë³´ê¸°", "ì´ Xëª…ì´ ì°¸ì—¬í–ˆì–´ìš”!"
- Progress screen: "ì§„í–‰ë¥ ", "ê²°ê³¼ ë¶„ì„ ì¤‘..."
- Result screen: "ë‹¹ì‹ ì˜ ê²°ê³¼", "ğŸ¯ íŠ¹ì§•", "âœ… ì¥ì ", "âš ï¸ ë‹¨ì ", "ğŸ’¡ ì¡°ì–¸"
- Compatibility: "ğŸ’– ìµœê³  ê¶í•©", "ğŸ˜Š ì¢‹ì€ ê¶í•©", "âš ï¸ ì£¼ì˜ í•„ìš”", "âŒ ì–´ë ¤ìš´ ê¶í•©"
- Action buttons: "ê²°ê³¼ ê³µìœ í•˜ê¸°", "ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•˜ê¸°", "ë‹¤ë¥¸ í…ŒìŠ¤íŠ¸ ë³´ê¸°"
- Section headers: "ğŸ”¥ ìš”ì¦˜ ì¸ê¸° í…ŒìŠ¤íŠ¸ ì¶”ì²œ í†±5", "ì—†ìŒ"

### 29. Result Title Emoji Management
âŒ DON'T:
- Include emojis in result title fields that should be clean text
- Mix emojis in titles with separate emoji fields
âœ… DO:
- Keep result titles clean without emojis (e.g., "ê·¹í•œ ì§ˆíˆ¬í˜•" not "ê·¹í•œ ì§ˆíˆ¬í˜• ğŸ”¥")
- Use separate emoji field for display purposes
- Remove emojis from all language title fields consistently

### 30. React Rendering Error Prevention
âŒ DON'T:
- Pass Record<string, string> objects directly as React children
- Render multilingual objects without extracting locale-specific strings
- Use partner.title directly in compatibility sections
âœ… DO:
- Always extract strings: typeof field === 'string' ? field : field[locale] || field.ko
- Use proper type checking for multilingual data
- Ensure all rendered content is string type, not object type

### 31. Multilingual Development Process
âœ… DO follow this complete process:
1. Create data structure with Record<string, string> from the beginning
2. Implement all UI text localization during initial development
3. Test all languages during development, not after completion
4. Use consistent patterns for all multilingual text handling
5. Verify no hardcoded strings remain in components
6. Test React rendering with all language combinations

## TypeScript Build Error Prevention (CRITICAL)

### 32. TypeScript Build Error Prevention
âŒ DON'T:
- Use string variables to index objects without proper type checking
- Access multilingual objects with dynamic locale strings without type assertions
- Ignore TypeScript errors during development that become build failures
- Skip build validation before deployment
- Deploy without successful production build
âœ… DO:
- Use type assertions: `obj[locale as keyof typeof obj]`
- Use proper type checking: `typeof field === 'string' ? field : field[locale] || field.ko`
- Fix all TypeScript errors before attempting production builds
- Always run `npm run build` before deployment
- Validate production build locally before pushing
- Test builds frequently during development

### 33. Development Server Cache Issues
âŒ DON'T:
- Ignore "Cannot find module" errors in development
- Continue development with corrupted cache
- Skip cache clearing when module errors occur
âœ… DO:
- Kill all Node processes: `taskkill /F /IM node.exe`
- Clear Next.js cache: `Remove-Item -Path .next -Recurse -Force`
- Clear node modules cache: `Remove-Item -Path node_modules\.cache -Recurse -Force`
- Restart development server after cache clearing

### 34. TypeScript Error Resolution Process
âœ… DO follow this exact process when TypeScript errors occur:
1. Identify the specific TypeScript error and location
2. Use proper type assertions for multilingual objects
3. Add explicit type annotations for function parameters
4. Test build after each fix
5. Clear cache if module errors persist
6. Restart development server if needed

### 35. Build Error Prevention Checklist
âœ… DO verify these before deployment:
- [ ] All TypeScript errors resolved
- [ ] Production build successful (`npm run build`)
- [ ] No "Cannot find module" errors
- [ ] All multilingual type assertions working
- [ ] Development server running without errors
- [ ] Cache cleared if module errors occurred

## Multilingual Comma Pattern Implementation (CRITICAL)

### 36. Language-Specific Comma Separation
âŒ DON'T:
- Use only English comma (,) for all languages
- Assume all languages use the same comma characters
- Hardcode comma separation without considering language-specific punctuation
âœ… DO:
- Support multiple comma types: English (,), Japanese (ã€), Chinese (ï¼Œ)
- Use regex pattern for comprehensive comma detection: /,\s+|ï¼Œ\s*|ã€\s*/
- Implement proper trimming and filtering for split results
- Test comma separation in all supported languages

### 37. Multilingual Comma Separation Implementation Pattern
âœ… DO use this pattern for splitting multilingual comma-separated content:
```typescript
const splitByCommas = (text: string) => {
  // ì‰¼í‘œ ë’¤ ê³µë°±ì„ í¬í•¨í•œ íŒ¨í„´ìœ¼ë¡œ ë¶„í• 
  return text.split(/,\s+|ï¼Œ\s*|ã€\s*/).map(item => item.trim()).filter(item => item.length > 0);
};

// Usage for result sections:
const resultSymptoms = splitByCommas(result.symptoms[locale] || result.symptoms.ko);
const resultPattern = splitByCommas(result.patterns[locale] || result.patterns.ko);
const resultRootCause = splitByCommas(result.causes[locale] || result.causes.ko);
const resultSolution = splitByCommas(result.solutions[locale] || result.solutions.ko);
```

### 38. Data Structure Consistency (CRITICAL)
âŒ DON'T:
- Mix string and Record<string, string> types in the same interface
- Keep unused properties in interfaces (e.g., scores at question level when moved to options)
- Assume data structure matches component expectations without verification
âœ… DO:
- Ensure all multilingual fields use Record<string, string> consistently
- Remove unused properties from interfaces when refactoring
- Verify component rendering logic matches actual data structure
- Test type assertions for all multilingual object access

### 39. Multilingual Data Consistency (CRITICAL)
âŒ DON'T:
- Use different comma patterns in data files vs component rendering
- Mix English commas (,) with Chinese commas (ï¼Œ) in the same data
- Assume all languages use the same punctuation conventions
âœ… DO:
- Use consistent comma patterns in data files for each language
- Chinese (zh-CN, zh-TW): Use Chinese comma (ï¼Œ) in data files
- Japanese (ja): Use Japanese comma (ã€) in data files
- Other languages: Use English comma (,) in data files
- Test comma separation in all languages during development

### 40. Component Data Access Pattern (CRITICAL)
âŒ DON'T:
- Access multilingual objects without proper type checking
- Assume data structure without verification
- Mix string and object access patterns
âœ… DO:
- Use consistent pattern: `typeof field === 'string' ? field : field[locale] || field.ko`
- Extract text first, then split: `const text = field[locale] || field.ko; const array = text.split(pattern)`
- Test all language combinations during development
- Verify type safety for all multilingual object access

### 41. Interface Design for Multilingual Support (CRITICAL)
âŒ DON'T:
- Keep unused properties in interfaces after refactoring
- Mix different data access patterns in the same interface
- Assume interface matches actual usage without verification
âœ… DO:
- Remove unused properties when refactoring data structure
- Use consistent Record<string, string> for all multilingual fields
- Verify interface matches component usage patterns
- Test interface changes with build validation

### 42. Development Process for Multilingual Features (CRITICAL)
âŒ DON'T:
- Implement multilingual features without considering comma patterns
- Skip language-specific testing during development
- Assume all languages work the same way
âœ… DO:
- Plan comma patterns from the beginning of multilingual implementation
- Test comma separation in all supported languages
- Use consistent patterns across all multilingual features
- Validate build after each language-specific change

These lessons ensure that future test development will have proper multilingual support from the beginning, avoiding the need for extensive refactoring later.

## Multilingual Quote Handling (CRITICAL)

### 43. Quote Escaping in Multilingual Text
âŒ DON'T:
- Use double quotes ("") inside multilingual text strings
- Use language-specific quote characters (Chinese quotes "") 
- Use double quotes ("") in Vietnamese or Indonesian text
- Ignore TypeScript syntax errors from quote conflicts
âœ… DO:
- Use backslash escaping for all quotes: \"
- Apply consistent quote pattern across all languages
- Test build after multilingual text changes

### 44. Correct Quote Pattern Examples
âœ… DO use this pattern for all multilingual text:
```typescript
// âŒ WRONG - causes build errors
'zh-CN': "ä½ æ˜¯å¦è¯´è¿‡"åªç›¸ä¿¡æˆ‘"ï¼Ÿ",
vi: ""NgÆ°á»i Ä‘Ã³ thá»±c sá»± Ä‘Ã¡ng tin cáº­y"",
id: ""Orang itu benar-benar dapat dipercaya""

// âœ… CORRECT - uses proper escaping
'zh-CN': "ä½ æ˜¯å¦è¯´è¿‡\"åªç›¸ä¿¡æˆ‘\"ï¼Ÿ",
vi: "\"NgÆ°á»i Ä‘Ã³ thá»±c sá»± Ä‘Ã¡ng tin certified\"",
id: "\"Orang itu benar-benar dapat dipercaya\""
```

### 45. Language-Specific Quote Guidelines
âœ… DO follow these patterns:
- **Korean/Japanese**: Use ã€Œã€ brackets (no issues)
- **English**: Use \" escaping
- **Chinese**: Use \" escaping (never use Chinese quotes "")
- **Vietnamese**: Use \" escaping  
- **Indonesian**: Use \" escaping

### 46. Build Error Prevention for Quotes
âœ… DO verify before build:
- [ ] All multilingual text uses \" escaping
- [ ] No double quotes ("") in any language text
- [ ] TypeScript syntax validation passes
- [ ] npm run build succeeds

## Trust Test Development Mistakes and Lessons (CRITICAL)

### 47. Result Screen Display Issues
âŒ DON'T:
- Display variable names instead of actual values in template literals
- Use incorrect variable interpolation syntax (e.g., [variableName] instead of ${variableName})
- Show compatibility descriptions as variable names (e.g., trustTest.result.compatibility.Type1_Type1)
- Leave result descriptions empty or incomplete
âœ… DO:
- Ensure proper variable interpolation: ${variableName} not [variableName]
- Use correct variable extraction: typeof result.title === 'string' ? result.title : result.title[locale] || result.title.ko
- Hardcode compatibility descriptions in getCompatibilityDescription function
- Add complete detailed descriptions to all result types in data files

### 48. Result Screen Layout and Spacing Issues
âŒ DON'T:
- Remove spacing classes (mb-3, mt-3) without considering layout impact
- Let sections stick together after removing elements
- Use inconsistent spacing patterns across compatibility sections
âœ… DO:
- Maintain consistent spacing: mb-3 for sections, mt-3 for top margins
- Test layout changes thoroughly before finalizing
- Ensure proper spacing between all result sections

### 49. Trust Score Display Format
âŒ DON'T:
- Use number type for trust scores when string format is required
- Display raw numbers instead of star ratings
âœ… DO:
- Use string type for trustScore in interface: trustScore: string
- Format scores as star ratings: "â˜…â˜…â˜…â˜…â˜… (5/5)" instead of 5
- Update all trustScore values to string format in data files

### 50. Compatibility Section Rendering
âŒ DON'T:
- Display compatibility items on multiple lines
- Show raw variable names in compatibility descriptions
- Use translation keys that return empty strings
âœ… DO:
- Render each compatibility item on a single line
- Hardcode compatibility descriptions in getCompatibilityDescription function
- Use proper JSX structure for single-line display

### 51. Multilingual UI Text Coverage
âŒ DON'T:
- Miss UI elements during multilingual implementation
- Leave hardcoded Korean text in components
- Forget to add new translation keys to all language files
- Use wrong translation keys for different contexts
âœ… DO:
- Cover ALL UI text elements: buttons, headers, messages, alerts
- Add translation keys to all 7 language files consistently
- Use appropriate translation keys for different contexts (similarTests vs similarTestsTop5)
- Test all languages during development

### 52. Debug Log Cleanup
âŒ DON'T:
- Leave console.log statements in production code
- Forget to remove debug logs after development
âœ… DO:
- Remove all console.log statements before finalizing
- Clean up debug logs in production builds
- Use proper logging practices for development only

### 53. Component State Management
âŒ DON'T:
- Call setShowResult(true) and setShowResultPopup(true) in handleAnswer
- Have conflicting state updates between different functions
- Forget to set loading spinner state properly
âœ… DO:
- Let handleShowResult manage result screen transitions
- Remove redundant state updates from handleAnswer
- Ensure proper loading spinner state management
- Test complete user flow from start to result

### 54. Data Structure Consistency
âŒ DON'T:
- Mix string and Record<string, string> types inconsistently
- Change data structure without updating component access patterns
- Assume data structure matches component expectations
âœ… DO:
- Use consistent Record<string, string> for all multilingual fields
- Update component rendering logic when changing data structure
- Verify data access patterns match actual data structure
- Test all language combinations during development

### 55. File Size and Operation Management
âŒ DON'T:
- Create massive files that cause "Tool call ended before result was received" errors
- Try to implement everything in a single large operation
- Work with files over 1000 lines in single operations
âœ… DO:
- Break down large implementations into small, manageable steps
- Implement features incrementally, step by step
- Process one language at a time for multilingual content
- Use incremental updates and frequent commits

## Question/Answer Shuffling and Calculation Logic (CRITICAL)

### 56. Shuffling Impact on Calculation Logic (CRITICAL)
âŒ DON'T:
- Ignore the impact of question/answer shuffling on calculation logic
- Store answers without question identification when shuffling is used
- Assume calculation logic works correctly with shuffled data
- Mix shuffled answer order with original question order in calculations
âœ… DO:
- Always store question ID with answers when shuffling is implemented
- Update calculation functions to handle both shuffled and non-shuffled data
- Test calculation accuracy with different shuffling scenarios
- Ensure consistent results regardless of question/answer order

### 57. Answer Storage Pattern for Shuffled Tests
âŒ DON'T:
- Store only scores without question context
- Use array index to identify questions when shuffling is active
- Assume original question order in calculation logic
âœ… DO:
- Store answers with question ID: `{ questionId: question.id, scores: scores }`
- Update calculation functions to handle new answer format
- Maintain backward compatibility with existing answer formats
- Test both shuffled and non-shuffled scenarios

### 58. Calculation Function Compatibility
âŒ DON'T:
- Break existing calculation logic when adding shuffling support
- Assume all tests use the same answer storage format
- Ignore backward compatibility when updating calculation functions
âœ… DO:
- Support both old and new answer formats in calculation functions
- Use conditional logic: `if (answer.scores) { /* new format */ } else { /* old format */ }`
- Test calculation accuracy with both formats
- Ensure consistent results across all test types

### 59. Shuffling Implementation Checklist
âœ… DO verify these when implementing shuffling:
- [ ] Question shuffling doesn't affect calculation accuracy
- [ ] Answer option shuffling doesn't affect scoring
- [ ] Calculation functions handle both shuffled and non-shuffled data
- [ ] Same answers produce same results regardless of order
- [ ] Backward compatibility maintained for existing tests
- [ ] All test scenarios work correctly with shuffling

### 60. Critical Shuffling Rules
âœ… DO follow these rules for all tests with shuffling:
1. **Always store question ID with answers** when shuffling is implemented
2. **Update calculation functions** to handle new answer format
3. **Test calculation accuracy** with different shuffling scenarios
4. **Maintain backward compatibility** with existing answer formats
5. **Verify consistent results** regardless of question/answer order

## Social Sharing Multilingual Requirements (CRITICAL)

### 61. Social Sharing Message Localization
âŒ DON'T:
- Hardcode Korean sharing messages in social sharing functions
- Use hardcoded Korean text in shareToKakao, shareToWeChat, shareToWhatsApp, shareToTelegram, shareToLine functions
- Leave alert messages in Korean only (e.g., "ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!", "ì¹´ì¹´ì˜¤í†¡ ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
- Ignore locale parameter in sharing functions
âœ… DO:
- Implement locale-based conditional rendering for ALL social sharing functions
- Use t() function for all sharing messages: `t('testName.shareMessages.platform', { type: resultTitle })`
- Localize ALL alert messages in sharing functions
- Create language-specific sharing messages for each platform
- Ensure consistent multilingual support across all sharing methods

### 62. Social Sharing Functions to Localize
âœ… DO localize ALL of these functions:
- handleShareResult() - Default sharing function
- shareToKakao() - KakaoTalk sharing
- shareToWeChat() - WeChat sharing  
- shareToWhatsApp() - WhatsApp sharing
- shareToTelegram() - Telegram sharing
- shareToLine() - Line sharing
- copyLink() - Link copy function

### 63. Social Sharing Message Pattern
âœ… DO use this pattern for all sharing messages:
```typescript
// In messages files (ko.json, en.json, etc.)
"testName": {
  "shareMessages": {
    "default": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°",
    "kakao": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°",
    "wechat": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°",
    "whatsapp": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°",
    "telegram": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°",
    "line": "ë‚˜ëŠ” {type}! í…ŒìŠ¤íŠ¸ ê²°ê³¼... ë„ˆëŠ” ì–´ë–»ê²Œ í•´? ê°™ì´ í•´ë³´ì! ğŸ’°"
  }
}

// In component functions
const shareText = t('testName.shareMessages.default', { type: resultTitle });
const shareDescription = t('testName.shareMessages.kakao', { type: resultTitle });
```

### 64. Alert Message Localization
âœ… DO localize ALL alert messages in sharing functions:
- Clipboard copy success messages
- Sharing feature error messages  
- WeChat link copy instructions
- KakaoTalk initialization messages
- Any user-facing text in sharing functions

### 65. UI Text Localization for Social Sharing
âœ… DO localize ALL UI elements related to social sharing:
- Button alt texts: `alt={t('testName.ui.linkCopy')}`, `alt={t('testName.ui.kakao')}`
- AdSense labels: `label={t('testName.ui.adsenseTitle')}`
- Similar tests section: `{t('testName.ui.similarTests')}`
- All user-facing text in result screens

### 66. Social Sharing Implementation Checklist
âœ… DO verify these when implementing social sharing:
- [ ] All sharing functions use t() for messages
- [ ] All alert messages are localized
- [ ] All UI text elements are localized
- [ ] All 7 languages have complete translation keys
- [ ] Share messages work correctly in all languages
- [ ] No hardcoded Korean text remains in components
- [ ] Consistent multilingual experience across all sharing platforms